---
interface Props {
  modelPath: string;
  canvasId?: string;
  autoRotate?: boolean;
  rotationSpeed?: number;
  backgroundColor?: string;
  decoderPath?: string;
}

const {
  modelPath,
  canvasId = 'model-canvas',
  autoRotate = true,
  rotationSpeed = 0.01,
  backgroundColor = '#202023',
  decoderPath = '/draco/',
} = Astro.props;
---

<div class="w-full h-full relative group pointer-events-auto">
  <canvas 
    id={canvasId} 
    class="w-full h-full model-3d-canvas cursor-grab active:cursor-grabbing pointer-events-auto"
    data-canvas-id={canvasId}
    data-model-path={modelPath}
    data-decoder-path={decoderPath}
    data-background-color={backgroundColor}
    data-auto-rotate={autoRotate.toString()}
    data-rotation-speed={rotationSpeed.toString()}
  ></canvas>
</div>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  import { loadDracoModel } from '../utils/loadDracoModel';
  import type { AnimationClip } from 'three';

  // Global state to track current animation loop
  let currentAnimationId: number | null = null;
  let currentIsAnimating = false;

  // Wait for DOM to be ready
  function initModel() {
    // Stop any existing animation loop before starting a new one
    if (currentIsAnimating && currentAnimationId !== null) {
      console.log('Model3D: Stopping existing animation loop before reinitializing');
      currentIsAnimating = false;
      cancelAnimationFrame(currentAnimationId);
      currentAnimationId = null;
    }
    // Find canvas by data attribute - this works even if ID is not set
    let canvas = document.querySelector('canvas[data-canvas-id]') as HTMLCanvasElement;
    if (!canvas) {
      console.error('Model3D: Canvas element with data-canvas-id not found');
      // Try to find by class as fallback
      canvas = document.querySelector('.model-3d-canvas') as HTMLCanvasElement;
      if (!canvas) {
        console.error('Model3D: No canvas element found');
        return;
      }
    }
    
    const canvasId = canvas.id || canvas.dataset.canvasId || 'model-canvas';
    console.log('Model3D: Found canvas', { id: canvasId, element: canvas });

    // Get props from data attributes
    const modelPath = canvas.dataset.modelPath || '/models/capybara.glb';
    const decoderPath = canvas.dataset.decoderPath || '/draco/';
    const backgroundColor = canvas.dataset.backgroundColor || '#202023';
    const autoRotate = canvas.dataset.autoRotate === 'true';
    const rotationSpeed = parseFloat(canvas.dataset.rotationSpeed || '0.01');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(backgroundColor);

    // Get canvas dimensions
    const canvasWidth = canvas.clientWidth || canvas.offsetWidth || 800;
    const canvasHeight = canvas.clientHeight || canvas.offsetHeight || 600;
    const aspect = canvasWidth / canvasHeight || 4 / 3;
    
    // Camera setup - adjusted for craftz.dog style layout
    const camera = new THREE.PerspectiveCamera(
      50, // FOV
      aspect,
      0.1,
      1000
    );
    // Initial camera position (top view - from above)
    const initialCameraPos = new THREE.Vector3(0, 3, 2);
    // Final camera position (front view)
    const finalCameraPos = new THREE.Vector3(0, 0, 5);
    camera.position.copy(initialCameraPos);
    camera.lookAt(0, 0, 0);

    // Renderer setup with shadow support
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: false,
    });
    
    // Ensure canvas CSS dimensions are 100% to follow container
    // This is critical for responsive behavior
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    
    renderer.setSize(canvasWidth, canvasHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // Shadows disabled - no ground plane needed
    
    console.log('Model3D: Canvas initialized', { 
      width: canvasWidth, 
      height: canvasHeight, 
      modelPath,
      canvasClientWidth: canvas.clientWidth,
      canvasClientHeight: canvas.clientHeight,
      canvasStyleWidth: canvas.style.width,
      canvasStyleHeight: canvas.style.height
    });

    // Simple ambient lighting only - no shadows or ground plane
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    // OrbitControls for mouse interaction
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true; // Smooth camera movement
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false; // Disable panning for better UX
    controls.minDistance = 2;
    controls.maxDistance = 10;
    controls.autoRotate = false; // Will be enabled after intro animation
    controls.autoRotateSpeed = rotationSpeed * 600; // Convert to degrees per second
    
    // Stop auto rotate when user interacts, resume after interaction ends
    controls.addEventListener('start', () => {
      controls.autoRotate = false;
    });
    
    // Resume auto rotate after user interaction ends (only if intro animation is complete)
    controls.addEventListener('end', () => {
      // Only resume if intro animation is complete and model has no built-in animations
      if (!introAnimationActive && (!gltfRef || !gltfRef.animations || gltfRef.animations.length === 0)) {
        controls.autoRotate = autoRotate;
      }
    });

    let model: THREE.Group | null = null;
    let mixer: THREE.AnimationMixer | null = null;
    const clock = new THREE.Clock();

    // Intro animation state
    let introAnimationActive = false;
    let introStartTime = 0;
    const introDuration = 2000; // 2.5 seconds
    const initialRotationSpeed = rotationSpeed * 50 * 10; // 5x faster initially
    const finalRotationSpeed = rotationSpeed * 200; // Normal speed

    // Animation loop control (local to this initModel call)
    let animationId: number | null = null;
    let isAnimating = false;

    // Easing function (easeOutCubic)
    function easeOutCubic(t: number): number {
      return 1 - Math.pow(1 - t, 3);
    }

    // Start render loop immediately to show background
    function animate() {
      // Check if animation should continue
      if (!isAnimating) {
        return;
      }

      animationId = requestAnimationFrame(animate);
      currentAnimationId = animationId; // Update global state

      // Safety check: ensure renderer, scene, and camera are still valid
      if (!renderer || !scene || !camera) {
        console.warn('Model3D: Renderer, scene, or camera is null, stopping animation');
        isAnimating = false;
        currentIsAnimating = false;
        currentAnimationId = null;
        return;
      }

      const elapsed = clock.getElapsedTime() * 1000; // Convert to milliseconds

      // Handle intro animation (camera movement + rotation speed)
      if (introAnimationActive && model) {
        const progress = Math.min((elapsed - introStartTime) / introDuration, 1);
        const easedProgress = easeOutCubic(progress);

        // Animate camera position from top to front
        camera.position.lerpVectors(initialCameraPos, finalCameraPos, easedProgress);
        camera.lookAt(0, 0, 0);

        // Animate rotation speed from fast to slow
        const currentSpeed = initialRotationSpeed + (finalRotationSpeed - initialRotationSpeed) * easedProgress;
        controls.autoRotateSpeed = currentSpeed;

        // End intro animation
        if (progress >= 1) {
          introAnimationActive = false;
          camera.position.copy(finalCameraPos);
          controls.autoRotateSpeed = finalRotationSpeed;
          // Enable auto rotate after intro
          if (!gltfRef || !gltfRef.animations || gltfRef.animations.length === 0) {
            controls.autoRotate = autoRotate;
          }
        }
      }

      // Update controls (required for damping)
      controls.update();

      // Update animations
      if (mixer) {
        const delta = clock.getDelta();
        mixer.update(delta);
      }

      renderer.render(scene, camera);
    }
    
    // Start animation loop
    isAnimating = true;
    currentIsAnimating = true; // Update global state
    // Start the animation loop - animationId will be set inside animate()
    animate();

    // Store gltf reference for intro animation check
    let gltfRef: { animations: AnimationClip[] } | null = null;

    // Load and add the 3D model
    console.log('Model3D: Loading model from', modelPath);
    loadDracoModel(modelPath, decoderPath)
      .then((gltf) => {
        gltfRef = gltf;
        console.log('Model3D: Model loaded successfully', gltf);
        model = gltf.scene;

        // Position model in lower third of canvas (craftz.dog style)
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // Scale to fit the container (slightly smaller for better composition)
        const maxDim = Math.max(size.x, size.y, size.z);
        const baseScale = 1.8 / maxDim;
        // Apply 1.2x initial zoom
        const scale = baseScale * 1.2;
        
        // Center horizontally and in depth first
        model.position.x = -center.x * scale;
        model.position.z = -center.z * scale;
        
        // Apply scaling
        model.scale.multiplyScalar(scale);

        // Recalculate bounding box after scaling
        const scaledBox = new THREE.Box3().setFromObject(model);
        const scaledMin = scaledBox.min;
        const scaledHeight = scaledBox.getSize(new THREE.Vector3()).y;
        
        // Position model in lower third of canvas
        // Canvas visible range is approximately -2.5 to 2.5 in Y
        // Lower third means bottom at around -0.8 to -1.2
        const lowerThirdY = -1.0; // Position for lower third
        model.position.y = lowerThirdY - scaledMin.y;
        
        console.log('Model3D: Model positioned in lower third', {
          scale,
          modelHeight: scaledHeight,
          modelBottom: scaledMin.y,
          finalY: model.position.y,
          lowerThirdY
        });

        scene.add(model);

        // Play animations if any
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(model);
          gltf.animations.forEach((clip: AnimationClip) => {
            mixer!.clipAction(clip).play();
          });
          // Disable auto rotate when animations are playing
          controls.autoRotate = false;
        }

        // Start intro animation (camera movement + rotation speed)
        if (!gltf.animations || gltf.animations.length === 0) {
          introAnimationActive = true;
          introStartTime = clock.getElapsedTime() * 1000;
          controls.autoRotate = true; // Enable rotation immediately for intro
          controls.autoRotateSpeed = initialRotationSpeed; // Start with fast rotation
        }

        console.log('Model3D: Model added to scene, starting intro animation');
      })
      .catch((error) => {
        console.error('Model3D: Failed to load 3D model:', error);
        console.error('Model3D: Error details:', {
          modelPath,
          decoderPath,
          error: error.message || error
        });
      });

    // Track last resize time to prevent conflicts between ResizeObserver and window resize
    let lastResizeTime = 0;
    const RESIZE_DEBOUNCE_MS = 200;

    // Handle resize with ResizeObserver for better responsiveness
    const handleResize = (entry?: ResizeObserverEntry) => {
      let newWidth: number;
      let newHeight: number;

      if (entry) {
        // Use ResizeObserver entry for precise dimensions
        // Prefer borderBoxSize if available (more accurate)
        if (entry.borderBoxSize && entry.borderBoxSize.length > 0) {
          newWidth = entry.borderBoxSize[0].inlineSize;
          newHeight = entry.borderBoxSize[0].blockSize;
        } else if (entry.contentBoxSize && entry.contentBoxSize.length > 0) {
          newWidth = entry.contentBoxSize[0].inlineSize;
          newHeight = entry.contentBoxSize[0].blockSize;
        } else {
          // Fallback to contentRect (deprecated but widely supported)
          const { width, height } = entry.contentRect;
          newWidth = width || canvas.clientWidth || 800;
          newHeight = height || canvas.clientHeight || 600;
        }
      } else {
        // Fallback: get dimensions from canvas or its container
        const container = canvas.parentElement;
        newWidth = canvas.clientWidth || container?.clientWidth || 800;
        newHeight = canvas.clientHeight || container?.clientHeight || 600;
      }

      // Ensure we have valid dimensions
      if (!newWidth || !newHeight || newWidth <= 0 || newHeight <= 0) {
        // Check if canvas is visible and connected to DOM
        const rect = canvas.getBoundingClientRect();
        const isConnected = canvas.isConnected;
        const hasValidRect = rect.width > 0 && rect.height > 0;
        
        // Try to get dimensions from getBoundingClientRect as fallback
        if (hasValidRect) {
          newWidth = rect.width;
          newHeight = rect.height;
          // If we got valid dimensions from rect, continue with resize
        } else if (!isConnected) {
          // Canvas is disconnected (e.g., during View Transitions), skip silently
          return;
        } else {
          // Canvas is connected but has invalid dimensions
          // This might happen during initial render or View Transitions
          // Only warn if canvas should be visible
          const computedStyle = window.getComputedStyle(canvas);
          const isDisplayed = computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden';
          
          if (isDisplayed) {
            // Canvas should be visible but has no dimensions - might be a timing issue
            // Use a small delay to retry
            setTimeout(() => {
              const retryRect = canvas.getBoundingClientRect();
              if (retryRect.width > 0 && retryRect.height > 0) {
                handleResize(entry);
              }
            }, 100);
          }
          return;
        }
      }

      // Get current renderer size (accounting for pixel ratio)
      const currentPixelRatio = renderer.getPixelRatio();
      const currentWidth = renderer.domElement.width / currentPixelRatio;
      const currentHeight = renderer.domElement.height / currentPixelRatio;

      // Skip if dimensions haven't changed (avoid unnecessary updates)
      // Use a small threshold to account for floating point precision
      if (Math.abs(newWidth - currentWidth) < 1 && Math.abs(newHeight - currentHeight) < 1) {
        return;
      }

      // Update camera aspect ratio
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();

      // Update renderer size and pixel ratio
      const pixelRatio = Math.min(window.devicePixelRatio, 2);
      renderer.setPixelRatio(pixelRatio);
      // setSize with updateStyle=false means we control CSS separately
      // This ensures canvas internal resolution matches display size
      renderer.setSize(newWidth, newHeight, false);
      
      // Ensure canvas CSS dimensions match container (important for responsive)
      // Three.js setSize sets the canvas width/height attributes (internal resolution)
      // We need to ensure CSS width/height stay at 100% to follow container
      if (canvas.style.width !== '100%' || canvas.style.height !== '100%') {
        canvas.style.width = '100%';
        canvas.style.height = '100%';
      }
      
      // Update controls
      controls.update();
      
      // Update last resize time to prevent window resize from overriding
      lastResizeTime = Date.now();
      
      // Verify actual canvas display size
      const actualDisplayWidth = canvas.clientWidth;
      const actualDisplayHeight = canvas.clientHeight;
      const actualRenderWidth = canvas.width;
      const actualRenderHeight = canvas.height;
      
      console.log('Model3D: Canvas resized', { 
        targetWidth: newWidth, 
        targetHeight: newHeight,
        actualDisplayWidth,
        actualDisplayHeight,
        actualRenderWidth,
        actualRenderHeight,
        pixelRatio,
        entry: !!entry,
        previousSize: { width: currentWidth, height: currentHeight }
      });
    };

    // Use ResizeObserver to watch canvas element size changes directly
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        console.log('Model3D: ResizeObserver triggered', { 
          width, 
          height, 
          target: entry.target.tagName,
          canvasWidth: canvas.clientWidth,
          canvasHeight: canvas.clientHeight
        });
        // Use requestAnimationFrame to ensure DOM has updated
        requestAnimationFrame(() => {
          handleResize(entry);
        });
      }
    });

    // Observe the canvas element itself for size changes
    resizeObserver.observe(canvas);
    console.log('Model3D: ResizeObserver attached to canvas', { 
      canvasWidth: canvas.clientWidth, 
      canvasHeight: canvas.clientHeight 
    });

    // Also observe the container in case canvas size is controlled by parent
    const container = canvas.parentElement;
    if (container) {
      resizeObserver.observe(container);
      console.log('Model3D: ResizeObserver attached to container', { 
        containerWidth: container.clientWidth, 
        containerHeight: container.clientHeight 
      });
    }

    // Also listen to window resize for device orientation changes
    // This is mainly a fallback - ResizeObserver should handle most cases
    let resizeTimeout: ReturnType<typeof setTimeout>;
    const windowResizeHandler = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const now = Date.now();
        // Skip if ResizeObserver just handled a resize (within debounce window)
        if (now - lastResizeTime < RESIZE_DEBOUNCE_MS) {
          console.log('Model3D: Skipping window resize (ResizeObserver handled it recently)');
          return;
        }

        // Force a resize check after a delay to ensure CSS has updated
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Double RAF ensures CSS transitions/animations have completed
            const container = canvas.parentElement;
            const newWidth = canvas.clientWidth || container?.clientWidth || 800;
            const newHeight = canvas.clientHeight || container?.clientHeight || 600;
            
            // Get current renderer size
            const currentPixelRatio = renderer.getPixelRatio();
            const currentWidth = renderer.domElement.width / currentPixelRatio;
            const currentHeight = renderer.domElement.height / currentPixelRatio;
            
            // Only update if dimensions actually differ (avoid duplicate updates)
            if (Math.abs(newWidth - currentWidth) > 1 || Math.abs(newHeight - currentHeight) > 1) {
              console.log('Model3D: Window resize handler triggered', { 
                newWidth, 
                newHeight, 
                currentWidth, 
                currentHeight 
              });
              handleResize();
            }
          });
        });
      }, RESIZE_DEBOUNCE_MS); // Delay to let ResizeObserver handle it first
    };
    window.addEventListener('resize', windowResizeHandler);

    // Cleanup on component unmount
    const cleanup = () => {
      // Stop animation loop first
      isAnimating = false;
      currentIsAnimating = false; // Update global state
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      if (currentAnimationId !== null) {
        cancelAnimationFrame(currentAnimationId);
        currentAnimationId = null;
      }

      resizeObserver.disconnect();
      window.removeEventListener('resize', windowResizeHandler);
      clearTimeout(resizeTimeout);
      if (mixer) {
        mixer.stopAllAction();
      }
      if (controls) {
        controls.dispose();
      }
      if (renderer) {
        renderer.dispose();
        // Force release WebGL context
        const gl = renderer.getContext();
        if (gl) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const loseContext = (gl as any).getExtension('WEBGL_lose_context');
          if (loseContext) {
            loseContext.loseContext();
          }
        }
      }
    };

    window.addEventListener('beforeunload', cleanup);
    
    // Also cleanup when page is hidden (for SPA navigation)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Optionally pause animation when page is hidden
      } else {
        // Resume when page becomes visible
        handleResize();
      }
    });

    // Handle Astro View Transitions - reinitialize model after page transition
    // View Transitions can cause canvas to be replaced, so we need to reinitialize
    const handlePageLoad = () => {
      console.log('Model3D: Page loaded via View Transitions, checking canvas');
      
      // First, check if there's a canvas on the current page
      // Use a small delay to ensure DOM is fully updated after transition
      setTimeout(() => {
        const currentCanvas = document.querySelector('canvas[data-canvas-id]') as HTMLCanvasElement || 
                              document.querySelector('.model-3d-canvas') as HTMLCanvasElement;
        
        // If no canvas exists on current page (e.g., we're on a detail page), do nothing
        if (!currentCanvas) {
          console.log('Model3D: No canvas found on current page, skipping');
          return;
        }
        
        // If canvas is not connected or changed, reinitialize the entire model
        if (!canvas.isConnected || (currentCanvas !== canvas && currentCanvas.isConnected)) {
          console.log('Model3D: Canvas disconnected or changed, reinitializing model', {
            originalConnected: canvas.isConnected,
            hasCurrentCanvas: !!currentCanvas,
            currentConnected: currentCanvas?.isConnected,
            canvasChanged: currentCanvas !== canvas
          });
          
          // Cleanup old instance
          cleanup();
          document.removeEventListener('astro:page-load', handlePageLoad);
          
          // Wait for WebGL context to be fully released, then reinitialize
          setTimeout(() => {
            initModel();
          }, 200);
          return;
        }
        
        // Canvas is still connected, continue with resize check
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Check if canvas is visible and has valid dimensions
              const rect = canvas.getBoundingClientRect();
              const checkWidth = rect.width || canvas.clientWidth || canvas.parentElement?.clientWidth || 0;
              const checkHeight = rect.height || canvas.clientHeight || canvas.parentElement?.clientHeight || 0;
              
              console.log('Model3D: Checking canvas after View Transition', {
                rect: { width: rect.width, height: rect.height },
                client: { width: canvas.clientWidth, height: canvas.clientHeight },
                check: { width: checkWidth, height: checkHeight }
              });
              
              if (checkWidth > 0 && checkHeight > 0) {
                // Canvas has valid dimensions, resize renderer
                console.log('Model3D: Canvas has valid dimensions, resizing', { checkWidth, checkHeight });
                handleResize();
                
                // Force a render to ensure model is visible
                if (model && scene && camera) {
                  renderer.render(scene, camera);
                }
              } else {
                // Canvas still has invalid dimensions, retry after delay
                console.warn('Model3D: Canvas still has invalid dimensions, retrying', { checkWidth, checkHeight });
                setTimeout(() => {
                  const retryRect = canvas.getBoundingClientRect();
                  const retryWidth = retryRect.width || canvas.clientWidth || canvas.parentElement?.clientWidth || 800;
                  const retryHeight = retryRect.height || canvas.clientHeight || canvas.parentElement?.clientHeight || 600;
                  
                  if (retryWidth > 0 && retryHeight > 0) {
                    console.log('Model3D: Retry successful, resizing', { retryWidth, retryHeight });
                    handleResize();
                    
                    // Force a render
                    if (model && scene && camera) {
                      renderer.render(scene, camera);
                    }
                  }
                }, 300);
              }
            });
          });
        });
      }, 50);
    };

    // Listen for Astro View Transitions page load event
    document.addEventListener('astro:page-load', handlePageLoad);
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initModel);
  } else {
    initModel();
  }
</script>
